<!DOCTYPE html>
<html>
<head>
    <title>WebRTC Voice Test Client</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            max-width: 800px; 
            margin: 20px auto; 
            padding: 20px; 
            background-color: #f5f5f5;
        }
        .control-panel { 
            margin: 20px 0; 
            padding: 20px; 
            border: 1px solid #ccc; 
            border-radius: 4px;
            background-color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .status { 
            margin: 10px 0; 
            padding: 10px;
            border-radius: 4px;
        }
        button { 
            margin: 5px; 
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
        }
        .error { 
            color: white;
            background-color: #ff5252;
        }
        .success { 
            color: white;
            background-color: #4CAF50;
        }
        input {
            padding: 8px;
            margin: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        label {
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <h1>WebRTC Voice Test Client</h1>
    
    <div class="control-panel">
        <h3>Connection Settings</h3>
        <div>
            <label for="roomId">Room ID:</label>
            <input type="text" id="roomId" value="test-room">
            <label for="peerId">Peer ID:</label>
            <input type="text" id="peerId">
        </div>
        <button onclick="connect()">Connect to Server</button>
        <button onclick="startCall()">Start Call</button>
        <button onclick="disconnect()">Disconnect</button>
    </div>

    <div class="control-panel">
        <h3>Audio Controls</h3>
        <button onclick="toggleMute()" id="muteButton">Mute</button>
        <div class="status" id="audioStatus">Audio status: Not connected</div>
    </div>

    <div class="status" id="connectionStatus">Not connected</div>
    <div class="status" id="peerList">No peers connected</div>

    <script>
        let ws;
        let peerConnection;
        let localStream;
        let isMuted = false;

        async function connect() {
            try {
                const peerId = document.getElementById('peerId').value || `user-${Math.random().toString(36).substr(2, 5)}`;
                document.getElementById('peerId').value = peerId;
                
                ws = new WebSocket('ws://127.0.0.1:8080');
                console.log('WebSocket connection attempting...');
                
                ws.onopen = () => {
                    console.log('WebSocket connection established');
                    updateStatus('Connected to signaling server');
                    const roomId = document.getElementById('roomId').value;
                    const peerId = document.getElementById('peerId').value;
                    const joinMessage = {
                        Join: {
                            room_id: roomId,
                            peer_id: peerId
                        }
                    };
                    console.log('Sending join message:', joinMessage);
                    ws.send(JSON.stringify(joinMessage));
                };

                ws.onmessage = (event) => {
                    try {
                        console.log("Raw message received:", event.data);
                        const message = JSON.parse(event.data);
                        console.log("Parsed message:", message);
                        
                        // Handle PeerList message specifically
                        if (message.message_type === "PeerList" && message.peers) {
                            console.log("Received peer list:", message.peers);
                            const peerListDiv = document.getElementById('peerList');
                            if (message.peers.length > 0) {
                                const currentPeerId = document.getElementById('peerId').value;
                                const otherPeers = message.peers.filter(p => p !== currentPeerId);
                                if (otherPeers.length > 0) {
                                    peerListDiv.textContent = 'Connected peers: ' + otherPeers.join(', ');
                                    peerListDiv.className = 'status success';
                                } else {
                                    peerListDiv.textContent = 'No other peers connected';
                                }
                            }
                        }
                    } catch (err) {
                        console.error('Failed to parse WebSocket message:', err);
                        console.log("Raw message that failed:", event.data);
                    }
                };
                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    updateStatus('WebSocket error: ' + error.message, true);
                };
                ws.onclose = () => {
                    console.log('WebSocket connection closed');
                    updateStatus('Disconnected from server', true);
                };

                localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                document.getElementById('audioStatus').textContent = 'Audio status: Ready';
            } catch (err) {
                updateStatus('Error: ' + err.message, true);
            }
        }

        function sendSignal(messageType, data = {}) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                let message = {
                    message_type: messageType,
                    room_id: data.room_id,
                    peer_id: data.peer_id,
                    sdp: data.sdp,
                    candidate: data.candidate,
                    from_peer: data.from_peer,
                    to_peer: data.to_peer
                };
                
                console.log("Sending message:", message);
                ws.send(JSON.stringify(message));
            }
        }

        async function startCall() {
            try {
                const roomId = document.getElementById('roomId').value;
                const peerId = document.getElementById('peerId').value;
                const peerListText = document.getElementById('peerList').textContent;
                console.log('Starting call. Current peer list:', peerListText);
                
                const peers = peerListText.includes('Connected peers: ') 
                    ? peerListText.replace('Connected peers: ', '').split(', ')
                    : [];
                
                console.log('Found peers to call:', peers);
                
                if (peers.length === 0) {
                    updateStatus('No other peers to call', true);
                    return;
                }

                await setupPeerConnection();

                // Create and send offer to each peer
                for (const targetPeer of peers) {
                    console.log('Creating offer for peer:', targetPeer);
                    const offer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(offer);
                    
                    console.log('Sending offer to peer:', targetPeer);
                    sendSignal('MediaOffer', {
                        room_id: roomId,
                        sdp: JSON.stringify(offer),
                        from_peer: peerId,
                        to_peer: targetPeer
                    });
                }

                updateStatus('Call started');
            } catch (err) {
                console.error('Error in startCall:', err);
                updateStatus('Call error: ' + err.message, true);
            }
        }

        async function handleSignaling(event) {
            const message = JSON.parse(event.data);
            console.log("Received message:", message);
            
            const messageType = Object.keys(message)[0];
            const data = message[messageType];
            console.log("Message type:", messageType, "Data:", data);

            switch (messageType) {
                case 'PeerList':
                    console.log('Received peer list:', data);
                    if (data.peers) {
                        const currentPeerId = document.getElementById('peerId').value;
                        const peers = data.peers.filter(p => p !== currentPeerId);
                        const peerListDiv = document.getElementById('peerList');
                        
                        if (peers.length > 0) {
                            peerListDiv.textContent = 'Connected peers: ' + peers.join(', ');
                            peerListDiv.className = 'status success';
                        } else {
                            peerListDiv.textContent = 'No other peers connected';
                            peerListDiv.className = 'status';
                        }
                        console.log('Updated peer list display:', peerListDiv.textContent);
                    }
                    break;
                case 'Offer':
                    if (data.to_peer === document.getElementById('peerId').value) {
                        console.log('Received offer, creating answer...');
                        if (!peerConnection) {
                            await setupPeerConnection();
                        }
                        await peerConnection.setRemoteDescription(new RTCSessionDescription({
                            type: 'offer',
                            sdp: JSON.parse(data.sdp)
                        }));
                        const answer = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answer);
                        
                        sendSignal('MediaAnswer', {
                            room_id: document.getElementById('roomId').value,
                            sdp: JSON.stringify(answer),
                            from_peer: document.getElementById('peerId').value,
                            to_peer: data.from_peer
                        });
                    }
                    break;
                case 'Answer':
                    if (data.to_peer === '*' || data.to_peer === peerId) {
                        await peerConnection.setRemoteDescription(new RTCSessionDescription({
                            type: 'answer',
                            sdp: data.sdp
                        }));
                    }
                    break;
                case 'IceCandidate':
                    if (data.to_peer === '*' || data.to_peer === peerId) {
                        await peerConnection.addIceCandidate(JSON.parse(data.candidate));
                    }
                    break;
            }
        }

        async function setupPeerConnection() {
            if (!localStream) {
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            }

            peerConnection = new RTCPeerConnection({
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' }
                ]
            });

            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            peerConnection.ontrack = event => {
                console.log('Received remote track');
                const audio = new Audio();
                audio.srcObject = event.streams[0];
                audio.play();
            };

            peerConnection.onicecandidate = event => {
                if (event.candidate) {
                    const roomId = document.getElementById('roomId').value;
                    const peerId = document.getElementById('peerId').value;
                    sendSignal('IceCandidate', {
                        room_id: roomId,
                        candidate: JSON.stringify(event.candidate),
                        from_peer: peerId,
                        to_peer: '*'
                    });
                }
            };
        }

        function toggleMute() {
            if (localStream) {
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = isMuted;
                });
                isMuted = !isMuted;
                document.getElementById('muteButton').textContent = isMuted ? 'Unmute' : 'Mute';
            }
        }

        function disconnect() {
            if (peerConnection) {
                peerConnection.close();
            }
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
            if (ws) {
                ws.close();
            }
            updateStatus('Disconnected');
        }

        function updateStatus(message, isError = false) {
            const status = document.getElementById('connectionStatus');
            status.textContent = message;
            status.className = 'status ' + (isError ? 'error' : 'success');
        }
    </script>
</body>
</html>
