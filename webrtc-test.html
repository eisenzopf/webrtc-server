<!DOCTYPE html>
<html>
<head>
    <title>WebRTC Voice Test Client</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            max-width: 800px; 
            margin: 20px auto; 
            padding: 20px; 
            background-color: #f5f5f5;
        }
        .control-panel { 
            margin: 20px 0; 
            padding: 20px; 
            border: 1px solid #ccc; 
            border-radius: 4px;
            background-color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .status { 
            margin: 10px 0; 
            padding: 10px;
            border-radius: 4px;
        }
        button { 
            margin: 5px; 
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
        }
        .error { 
            color: white;
            background-color: #ff5252;
        }
        .success { 
            color: white;
            background-color: #4CAF50;
        }
        input {
            padding: 8px;
            margin: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        label {
            margin-right: 10px;
        }
        .peer-list {
            margin: 10px 0;
            max-height: 200px;
            overflow-y: auto;
        }
        .peer-item {
            display: flex;
            align-items: center;
            padding: 5px;
            margin: 2px 0;
            background: #f0f0f0;
            border-radius: 4px;
        }
        .peer-item input[type="checkbox"] {
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <h1>WebRTC Voice Test Client</h1>
    
    <div class="control-panel">
        <h3>Connection Settings</h3>
        <div>
            <label for="roomId">Room ID:</label>
            <input type="text" id="roomId" value="test-room">
            <label for="peerId">Peer ID:</label>
            <input type="text" id="peerId">
        </div>
        <button onclick="connect()">Connect to Server</button>
        <button onclick="startCall()">Start Call</button>
        <button onclick="endCall()">End Call</button>
        <button onclick="disconnect()">Disconnect</button>
    </div>

    <div class="control-panel">
        <h3>Audio Controls</h3>
        <button onclick="toggleMute()" id="muteButton">Mute</button>
        <div class="status" id="audioStatus">Audio status: Not connected</div>
    </div>

    <div class="control-panel">
        <h3>Available Peers</h3>
        <div id="selectablePeerList" class="peer-list">
            <!-- Peers will be dynamically added here -->
        </div>
        <button onclick="startCall()">Call Selected Peers</button>
    </div>

    <div class="status" id="connectionStatus">Not connected</div>
    <div class="status" id="peerList">No peers connected</div>

    <script>
        let ws;
        let peerConnection;
        let localStream;
        let isMuted = false;
        let isDisconnecting = false;
        let peerConnections = {};  // Store multiple peer connections
        let activeCallRequests = new Set();  // Track pending call requests
        let remotePeerId = null;

        window.addEventListener('beforeunload', () => {
            if (!isDisconnecting) {
                disconnect();
            }
        });

        async function connect() {
            try {
                const peerId = document.getElementById('peerId').value || `user-${Math.random().toString(36).substr(2, 5)}`;
                document.getElementById('peerId').value = peerId;
                
                ws = new WebSocket('ws://127.0.0.1:8080');
                console.log('WebSocket connection attempting...');
                
                ws.onopen = () => {
                    console.log('WebSocket connection established');
                    updateStatus('Connected to signaling server');
                    const roomId = document.getElementById('roomId').value;
                    const peerId = document.getElementById('peerId').value;
                    const joinMessage = {
                        message_type: 'Join',
                        room_id: roomId,
                        peer_id: peerId
                    };
                    console.log('Sending join message:', joinMessage);
                    ws.send(JSON.stringify(joinMessage));
                };

                ws.onmessage = async (event) => {
                    try {
                        // Check if it's a text message
                        if (typeof event.data !== 'string') {
                            console.log("Received non-text message, ignoring");
                            return;
                        }

                        console.log("Raw message received:", event.data);
                        const message = JSON.parse(event.data);
                        console.log("Parsed message:", message);
                        
                        switch (message.message_type) {
                            case "PeerList":
                                const currentPeerId = document.getElementById('peerId').value;
                                const otherPeers = message.peers.filter(p => p !== currentPeerId);
                                const peerListDiv = document.getElementById('selectablePeerList');
                                
                                peerListDiv.innerHTML = otherPeers.map(peerId => `
                                    <div class="peer-item">
                                        <input type="checkbox" id="peer_${peerId}" value="${peerId}">
                                        <label for="peer_${peerId}">${peerId}</label>
                                    </div>
                                `).join('');
                                break;

                            case "Offer":
                                console.log("Received offer from:", message.from_peer);
                                try {
                                    if (!peerConnection) {
                                        await setupPeerConnection();
                                    }

                                    if (peerConnection.signalingState !== "stable") {
                                        console.log("Ignoring offer - not in stable state");
                                        return;
                                    }

                                    const offerDesc = {
                                        type: 'offer',
                                        sdp: message.sdp.replace(/\\r\\n/g, '\r\n')
                                    };

                                    console.log("Setting remote description (offer)");
                                    await peerConnection.setRemoteDescription(new RTCSessionDescription(offerDesc));

                                    console.log("Creating answer");
                                    const answer = await peerConnection.createAnswer();
                                    
                                    console.log("Setting local description (answer)");
                                    await peerConnection.setLocalDescription(answer);

                                    console.log("Sending answer to:", message.from_peer);
                                    sendSignal('Answer', {
                                        room_id: document.getElementById('roomId').value,
                                        sdp: answer.sdp,
                                        from_peer: document.getElementById('peerId').value,
                                        to_peer: message.from_peer
                                    });
                                } catch (err) {
                                    console.error("Error handling offer:", err);
                                }
                                break;

                            case "Answer":
                                console.log("Received answer from:", message.from_peer);
                                try {
                                    if (!peerConnection) {
                                        console.log("No peer connection available for answer");
                                        return;
                                    }

                                    if (peerConnection.signalingState === "have-local-offer") {
                                        console.log("Setting remote description (answer)");
                                        await peerConnection.setRemoteDescription(new RTCSessionDescription({
                                            type: 'answer',
                                            sdp: message.sdp
                                        }));
                                    } else {
                                        console.log("Ignoring answer - not in have-local-offer state, current state:", peerConnection.signalingState);
                                    }
                                } catch (err) {
                                    console.error("Error handling answer:", err);
                                }
                                break;

                            case "IceCandidate":
                                console.log("Received ICE candidate message:", message);
                                if (peerConnection && peerConnection.remoteDescription) {
                                    try {
                                        const candidate = JSON.parse(message.candidate);
                                        console.log("Parsed ICE candidate:", candidate);
                                        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                                        console.log("Successfully added ICE candidate");
                                    } catch (e) {
                                        console.error("Error adding received ICE candidate:", e);
                                    }
                                } else {
                                    console.log("Ignoring ICE candidate - no peer connection or remote description");
                                    console.log("PeerConnection:", !!peerConnection);
                                    console.log("RemoteDescription:", peerConnection?.remoteDescription);
                                }
                                break;

                            case "EndCall":
                                if (peerConnection) {
                                    peerConnection.close();
                                    peerConnection = null;
                                    if (localStream) {
                                        localStream.getTracks().forEach(track => track.stop());
                                        localStream = null;
                                    }
                                    updateStatus('Call ended by peer');
                                    document.getElementById('audioStatus').textContent = 'Audio status: Not in call';
                                }
                                break;

                            case "CallRequest":
                                console.log("Received CallRequest message:", message);
                                if (message.to_peers.includes(document.getElementById('peerId').value)) {
                                    remotePeerId = message.from_peer;
                                    updateStatus(`Incoming call from ${remotePeerId}`);
                                    // Accept call and create peer connection
                                    sendSignal('CallResponse', {
                                        room_id: document.getElementById('roomId').value,
                                        from_peer: document.getElementById('peerId').value,
                                        to_peer: remotePeerId,
                                        accepted: true
                                    });
                                    await setupPeerConnection();
                                }
                                break;

                            case "CallResponse":
                                if (message.to_peer === document.getElementById('peerId').value && message.accepted) {
                                    remotePeerId = message.from_peer;
                                    updateStatus(`Call accepted by ${remotePeerId}`);
                                    // Create RTCPeerConnection and continue with the call setup
                                    await setupPeerConnection();
                                    
                                    // Create and send offer
                                    const offer = await peerConnection.createOffer({
                                        offerToReceiveAudio: true
                                    });
                                    await peerConnection.setLocalDescription(offer);
                                    
                                    sendSignal('Offer', {
                                        room_id: document.getElementById('roomId').value,
                                        sdp: offer.sdp,
                                        from_peer: document.getElementById('peerId').value,
                                        to_peer: remotePeerId
                                    });
                                }
                                break;
                        }
                    } catch (err) {
                        console.error('Failed to process WebSocket message:', err);
                        console.log("Raw message that failed:", event.data);
                    }
                };
                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    updateStatus('WebSocket error occurred', true);
                };
                ws.onclose = (event) => {
                    console.log('WebSocket connection closed:', event.code, event.reason);
                    updateStatus('Connection closed');
                    
                    if (!isDisconnecting) {
                        if (peerConnection) {
                            peerConnection.close();
                            peerConnection = null;
                        }
                        if (localStream) {
                            localStream.getTracks().forEach(track => track.stop());
                            localStream = null;
                        }
                        const roomId = document.getElementById('roomId').value;
                        const peerId = document.getElementById('peerId').value;
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            sendSignal('Disconnect', {
                                room_id: roomId,
                                peer_id: peerId
                            });
                        }
                    }
                };

                const constraints = {
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    },
                    video: false
                };

                try {
                    localStream = await navigator.mediaDevices.getUserMedia(constraints);
                    console.log('Got local stream with tracks:', localStream.getTracks().map(t => ({
                        kind: t.kind,
                        enabled: t.enabled,
                        muted: t.muted,
                        settings: t.getSettings()
                    })));
                } catch (err) {
                    console.error('Error getting local stream:', err);
                    updateStatus('Error getting local stream: ' + err.message, true);
                    return null;
                }
                document.getElementById('audioStatus').textContent = 'Audio status: Ready';
            } catch (err) {
                updateStatus('Error: ' + err.message, true);
            }
        }

        function sendSignal(messageType, data = {}) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const message = {
                    message_type: messageType,
                    ...data  // Spread the data object directly
                };
                
                // Remove any undefined fields
                Object.keys(message).forEach(key => 
                    message[key] === undefined && delete message[key]
                );
                
                console.log("Sending message:", message);
                ws.send(JSON.stringify(message));
            } else {
                console.error("WebSocket is not open");
            }
        }

        async function startCall() {
            const selectedPeers = Array.from(document.querySelectorAll('#selectablePeerList input[type="checkbox"]:checked'))
                .map(cb => cb.value);
            
            if (selectedPeers.length === 0) {
                updateStatus('Please select at least one peer to call', true);
                return;
            }

            // Send call request to selected peers
            sendSignal('CallRequest', {
                room_id: document.getElementById('roomId').value,
                from_peer: document.getElementById('peerId').value,
                to_peers: selectedPeers
            });
            
            updateStatus(`Calling ${selectedPeers.length} peer(s)...`);
            activeCallRequests = new Set(selectedPeers);
        }

        async function handleSignaling(event) {
            const message = JSON.parse(event.data);
            console.log("Received message:", message);
            
            const messageType = Object.keys(message)[0];
            const data = message[messageType];
            console.log("Message type:", messageType, "Data:", data);

            switch (messageType) {
                case 'PeerList':
                    console.log('Received peer list:', data);
                    if (data.peers) {
                        const currentPeerId = document.getElementById('peerId').value;
                        const peers = data.peers.filter(p => p !== currentPeerId);
                        const peerListDiv = document.getElementById('peerList');
                        
                        if (peers.length > 0) {
                            peerListDiv.textContent = 'Connected peers: ' + peers.join(', ');
                            peerListDiv.className = 'status success';
                        } else {
                            peerListDiv.textContent = 'No other peers connected';
                            peerListDiv.className = 'status';
                        }
                        console.log('Updated peer list display:', peerListDiv.textContent);
                    }
                    break;
                case 'Offer':
                    if (data.to_peer === document.getElementById('peerId').value) {
                        console.log('Received offer, creating answer...');
                        if (!peerConnection) {
                            await setupPeerConnection();
                        }
                        await peerConnection.setRemoteDescription(new RTCSessionDescription({
                            type: 'offer',
                            sdp: JSON.parse(data.sdp)
                        }));
                        const answer = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answer);
                        
                        sendSignal('MediaAnswer', {
                            room_id: document.getElementById('roomId').value,
                            sdp: JSON.stringify(answer),
                            from_peer: document.getElementById('peerId').value,
                            to_peer: data.from_peer
                        });
                    }
                    break;
                case 'Answer':
                    if (data.to_peer === '*' || data.to_peer === peerId) {
                        await peerConnection.setRemoteDescription(new RTCSessionDescription({
                            type: 'answer',
                            sdp: data.sdp
                        }));
                    }
                    break;
                case 'IceCandidate':
                    if (peerConnection) {
                        try {
                            await peerConnection.addIceCandidate(new RTCIceCandidate(message.candidate));
                            console.log('Added ICE candidate from peer:', message.from_peer);
                        } catch (err) {
                            console.error('Error adding ICE candidate:', err);
                        }
                    }
                    break;
            }
        }

        async function setupPeerConnection() {
            if (!localStream) {
                console.log("Getting user media");
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                const audioTracks = localStream.getAudioTracks();
                console.log('Local audio tracks:', audioTracks.map(track => ({
                    id: track.id,
                    enabled: track.enabled,
                    muted: track.muted,
                    readyState: track.readyState,
                    label: track.label,
                    settings: track.getSettings()
                })));
            }

            console.log("Creating new RTCPeerConnection");
            peerConnection = new RTCPeerConnection({
                sdpSemantics: 'unified-plan'
            });

            peerConnection.ontrack = event => {
                console.log('Track received:', {
                    kind: event.track.kind,
                    readyState: event.track.readyState,
                    enabled: event.track.enabled,
                    muted: event.track.muted,
                    id: event.track.id
                });

                if (event.track.kind === 'audio') {
                    // Create audio element if it doesn't exist
                    let audioElement = document.getElementById('remoteAudio');
                    if (!audioElement) {
                        audioElement = document.createElement('audio');
                        audioElement.id = 'remoteAudio';
                        audioElement.autoplay = true;
                        audioElement.playsInline = true;
                        audioElement.controls = true;
                        audioElement.volume = 1.0;  // Ensure volume is max
                        document.body.appendChild(audioElement);
                        console.log('Created new audio element:', audioElement);
                    }

                    // Create a new MediaStream with the received track
                    const stream = new MediaStream([event.track]);
                    audioElement.srcObject = stream;
                    console.log('Set stream to audio element:', {
                        stream: stream.active,
                        tracks: stream.getTracks().map(t => ({
                            kind: t.kind,
                            enabled: t.enabled,
                            muted: t.muted
                        }))
                    });

                    // Try to play immediately
                    audioElement.play()
                        .then(() => console.log('Initial audio playback started'))
                        .catch(e => console.error('Initial play failed:', e));

                    // Monitor track state
                    event.track.onunmute = () => {
                        console.log('Remote track unmuted, attempting playback');
                        audioElement.play()
                            .then(() => console.log('Audio playback started after unmute'))
                            .catch(e => console.error('Play after unmute failed:', e));
                    };

                    // Add periodic audio element state checking
                    setInterval(() => {
                        console.log('Audio element state:', {
                            paused: audioElement.paused,
                            muted: audioElement.muted,
                            volume: audioElement.volume,
                            hasAudio: !audioElement.mozHasAudio !== undefined 
                                ? audioElement.mozHasAudio 
                                : audioElement.webkitAudioDecodedByteCount > 0
                        });
                    }, 2000);
                }
            };

            peerConnection.onicecandidate = event => {
                if (event.candidate) {
                    console.log('Sending ICE candidate:', event.candidate);
                    sendSignal('IceCandidate', {
                        room_id: document.getElementById('roomId').value,
                        candidate: {
                            candidate: event.candidate.candidate,
                            sdpMid: event.candidate.sdpMid,
                            sdpMLineIndex: event.candidate.sdpMLineIndex
                        },
                        from_peer: document.getElementById('peerId').value,
                        to_peer: remotePeerId
                    });
                }
            };

            console.log("Adding local tracks to connection");
            localStream.getTracks().forEach(track => {
                track.enabled = true;
                const sender = peerConnection.addTrack(track, localStream);
                console.log('Local track added:', {
                    kind: track.kind,
                    enabled: track.enabled,
                    muted: track.muted,
                    id: track.id
                });

                // Monitor track state changes
                track.onended = () => console.log('Local track ended:', track.id);
                track.onmute = () => console.log('Local track muted:', track.id);
                track.onunmute = () => console.log('Local track unmuted:', track.id);
            });

            peerConnection.onconnectionstatechange = () => {
                console.log('Connection state changed:', peerConnection.connectionState);
                updateCallStatus(peerConnection.connectionState);
            };

            peerConnection.oniceconnectionstatechange = () => {
                console.log('ICE Connection State Change:', {
                    iceConnectionState: peerConnection.iceConnectionState,
                    signalingState: peerConnection.signalingState,
                    connectionState: peerConnection.connectionState,
                    iceGatheringState: peerConnection.iceGatheringState
                });

                if (peerConnection.iceConnectionState === 'connected') {
                    console.log('ICE Connection established');
                    // Start monitoring audio levels for both local and remote tracks
                    const audioElement = document.getElementById('remoteAudio');
                    if (audioElement && audioElement.srcObject) {
                        monitorAudioState(audioElement.srcObject);
                    }
                    if (localStream) {
                        monitorAudioState(localStream);
                    }
                } else if (peerConnection.iceConnectionState === 'failed') {
                    console.error('ICE Connection failed');
                    updateCallStatus('failed');
                }
            };

            peerConnection.onicegatheringstatechange = () => {
                console.log('ICE Gathering State Change:', peerConnection.iceGatheringState);
            };

            peerConnection.onsignalingstatechange = () => {
                console.log('Signaling State Change:', peerConnection.signalingState);
            };

            peerConnection.onconnectionstatechange = () => {
                const state = {
                    connectionState: peerConnection.connectionState,
                    iceConnectionState: peerConnection.iceConnectionState,
                    signalingState: peerConnection.signalingState,
                    iceGatheringState: peerConnection.iceGatheringState
                };
                console.log('Connection State Change:', state);
                
                if (peerConnection.connectionState === 'connected') {
                    console.log('WebRTC connection established');
                    updateCallStatus('connected', remotePeerId);
                    
                    // Start monitoring both local and remote audio
                    const audioElement = document.getElementById('remoteAudio');
                    if (audioElement && audioElement.srcObject) {
                        monitorAudioState(audioElement.srcObject);
                    }
                    if (localStream) {
                        monitorAudioState(localStream);
                    }
                } else if (peerConnection.connectionState === 'failed' || 
                           peerConnection.connectionState === 'disconnected') {
                    console.log('WebRTC connection failed or disconnected');
                    updateCallStatus(peerConnection.connectionState);
                }
            };

            return peerConnection;
        }

        function toggleMute() {
            if (localStream) {
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = isMuted;
                    console.log(`Audio track ${track.id} enabled:`, track.enabled);
                });
                isMuted = !isMuted;
                document.getElementById('muteButton').textContent = isMuted ? 'Unmute' : 'Mute';
            }
        }

        function disconnect() {
            try {
                isDisconnecting = true;
                if (ws && ws.readyState === WebSocket.OPEN) {
                    const roomId = document.getElementById('roomId').value;
                    const peerId = document.getElementById('peerId').value;
                    
                    sendSignal('Disconnect', {
                        room_id: roomId,
                        peer_id: peerId
                    });
                }

                if (peerConnection) {
                    peerConnection.close();
                    peerConnection = null;
                }

                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    localStream = null;
                }

                if (ws) {
                    ws.close();
                    ws = null;
                }

                updateStatus('Disconnected');
                document.getElementById('audioStatus').textContent = 'Audio status: Not connected';
                document.getElementById('peerList').textContent = 'No peers connected';
                document.getElementById('peerList').className = 'status';
            } catch (err) {
                console.error('Error during disconnect:', err);
                updateStatus('Disconnect error: ' + err.message, true);
            }
        }

        function updateStatus(message, isError = false) {
            console.log(`Status update (${new Date().toISOString()}):`, {
                message,
                isError,
                peerConnection: peerConnection ? {
                    iceConnectionState: peerConnection.iceConnectionState,
                    connectionState: peerConnection.connectionState,
                    signalingState: peerConnection.signalingState
                } : null
            });
            const status = document.getElementById('connectionStatus');
            status.textContent = message;
            status.className = isError ? 'error' : 'success';
        }

        async function endCall() {
            try {
                if (peerConnection) {
                    // Close the peer connection
                    peerConnection.close();
                    peerConnection = null;

                    // Stop local stream tracks
                    if (localStream) {
                        localStream.getTracks().forEach(track => track.stop());
                        localStream = null;
                    }

                    // Send end call signal to the server
                    const roomId = document.getElementById('roomId').value;
                    const peerId = document.getElementById('peerId').value;
                    sendSignal('EndCall', {
                        room_id: roomId,
                        peer_id: peerId
                    });

                    updateStatus('Call ended');
                    document.getElementById('audioStatus').textContent = 'Audio status: Not in call';
                } else {
                    updateStatus('No active call to end');
                }
            } catch (err) {
                console.error('Error ending call:', err);
                updateStatus('Error ending call: ' + err.message, true);
            }
        }

        function showCallAlert(caller) {
            return new Promise((resolve) => {
                const result = window.confirm(`Incoming call from ${caller}. Accept?`);
                resolve(result);
            });
        }

        function setupAudioLevelMonitoring(stream) {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContext.createMediaStreamSource(stream);
            const analyser = audioContext.createAnalyser();
            
            analyser.fftSize = 2048;
            analyser.minDecibels = -90;
            analyser.maxDecibels = -10;
            analyser.smoothingTimeConstant = 0.85;
            
            source.connect(analyser);
            // Remove connection to destination to prevent feedback
            // analyser.connect(audioContext.destination);
            
            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            
            function checkAudioLevel() {
                analyser.getByteFrequencyData(dataArray);
                const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
                
                if (average > 0) {
                    console.log('Audio level detected:', {
                        average,
                        stream: stream.id,
                        tracks: stream.getTracks().map(t => ({
                            id: t.id,
                            kind: t.kind,
                            enabled: t.enabled,
                            muted: t.muted
                        }))
                    });
                }
                requestAnimationFrame(checkAudioLevel);
            }
            
            checkAudioLevel();
            
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        function setupVolumeIndicator() {
            const volumeDiv = document.createElement('div');
            volumeDiv.style.padding = '10px';
            volumeDiv.style.margin = '10px';
            volumeDiv.style.border = '1px solid #ccc';
            document.body.appendChild(volumeDiv);
            
            return volumeDiv;
        }

        function addDebugButton() {
            const button = document.createElement('button');
            button.textContent = 'Check Audio State';
            button.onclick = () => {
                if (peerConnection) {
                    const receivers = peerConnection.getReceivers();
                    receivers.forEach(receiver => {
                        console.log('Receiver track state:', {
                            kind: receiver.track.kind,
                            readyState: receiver.track.readyState,
                            enabled: receiver.track.enabled,
                            muted: receiver.track.muted,
                            volume: receiver.track.volume
                        });
                    });
                }
            };
            document.body.appendChild(button);
        }

        function monitorAudioState(stream) {
            const audioTracks = stream.getAudioTracks();
            audioTracks.forEach(track => {
                console.log('Audio track state:', {
                    enabled: track.enabled,
                    muted: track.muted,
                    readyState: track.readyState,
                    id: track.id,
                    settings: track.getSettings()
                });

                // Add volume meter
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaStreamSource(new MediaStream([track]));
                const analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                source.connect(analyser);
                
                function checkLevel() {
                    const dataArray = new Uint8Array(analyser.frequencyBinCount);
                    analyser.getByteFrequencyData(dataArray);
                    const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
                    if (average > 0) {
                        console.log(`Track ${track.id} level:`, average);
                    }
                    requestAnimationFrame(checkLevel);
                }
                checkLevel();
            });
        }

        function updateCallStatus(state, peer = null) {
            const statusMsg = peer ? `${state} with ${peer}` : state;
            updateStatus(statusMsg);
            
            if (state === 'connected') {
                document.getElementById('audioStatus').textContent = 'Audio status: Connected';
                document.getElementById('connectionStatus').className = 'status success';
            } else if (state === 'disconnected' || state === 'failed') {
                document.getElementById('audioStatus').textContent = 'Audio status: Not connected';
                document.getElementById('connectionStatus').className = 'status error';
            }
        }

        function addAudioDebugButton() {
            const button = document.createElement('button');
            button.textContent = 'Debug Audio';
            button.onclick = () => {
                const audioElement = document.getElementById('remoteAudio');
                console.log('Audio element state:', {
                    exists: !!audioElement,
                    srcObject: !!audioElement?.srcObject,
                    paused: audioElement?.paused,
                    muted: audioElement?.muted,
                    volume: audioElement?.volume
                });
                
                if (peerConnection) {
                    const receivers = peerConnection.getReceivers();
                    receivers.forEach(receiver => {
                        if (receiver.track.kind === 'audio') {
                            console.log('Audio receiver:', {
                                track: receiver.track,
                                transport: receiver.transport,
                                params: receiver.getParameters()
                            });
                        }
                    });
                }
            };
            document.body.appendChild(button);
        }

        // Call this after connection is established
        addDebugButton();
        addAudioDebugButton();
    </script>
</body>
</html>
